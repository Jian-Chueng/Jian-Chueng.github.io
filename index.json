[{"authors":["admin"],"categories":null,"content":"Jian Zhang is currently a Ph.D. Candidate with the School of Electrical Engineering and Telecommunications, University of New South Wales (UNSW), Australia. She received her B.Sc. (Magna Cum Laude) degree in Electrical Engineering in 2016 from Kennesaw State University, Georgia, USA. Her current research interests include machine learning and intelligent control, hybrid systems, navigation, and control of mobile robots.\n","date":1587772800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":1587772800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://jianzhang6.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"Jian Zhang is currently a Ph.D. Candidate with the School of Electrical Engineering and Telecommunications, University of New South Wales (UNSW), Australia. She received her B.Sc. (Magna Cum Laude) degree in Electrical Engineering in 2016 from Kennesaw State University, Georgia, USA. Her current research interests include machine learning and intelligent control, hybrid systems, navigation, and control of mobile robots.","tags":null,"title":"Jian Zhang","type":"authors"},{"authors":["Jian Zhang"],"categories":["data structure"],"content":"数据结构和算法（Python） 教材\n视频课\n01什么是算法 算法就是计算机处理信息的本质，因为计算机程序的本质就是一个算法来高速计算机确切的步骤来执行一个指定的任务。 算法是独立存在的解决问题的方法和思 想，实现的语言不重要\n算法的5特性： 输入：0或多个 输出：至少一个 有穷性：算法有限的步骤之后不会无限循环，并且在可以接受的时间内完成 确定性：算法中的每一步都有确定的含义 可行性：每一步都是可行的，也就是都能执行有限的次数完成\n教材：数据结构与算法：python语言描述 进阶：算法导论（更深，重点学思想\nimport time start_time = time.time() for a in range(0,1001): for b in range(0,1001): for c in range(0,1001): if a**2+b**2 == c**2 and a+b+c ==1000: print(\u0026quot;a, b, c: %d, %d, %d\u0026quot; % (a,b,c)) end_time = time.time() print(\u0026quot;Duration: %d\u0026quot; %(end_time-start_time)) print(\u0026quot;finished\u0026quot;)  a, b, c: 0, 500, 500 a, b, c: 200, 375, 425 a, b, c: 375, 200, 425 a, b, c: 500, 0, 500 Duration: 682 finished  改进： 因为a,b 确定下来c也就确定了\nimport time start_time = time.time() for a in range(0,1001): for b in range(0,1001): c = 1000-a-b if a**2+b**2 == c**2: print(\u0026quot;a, b, c: %d, %d, %d\u0026quot; % (a,b,c)) end_time = time.time() print(\u0026quot;Duration: %f\u0026quot; %(end_time-start_time)) print(\u0026quot;finished\u0026quot;)  a, b, c: 0, 500, 500 a, b, c: 200, 375, 425 a, b, c: 375, 200, 425 a, b, c: 500, 0, 500 Duration: 0.905913 finished  02 算法效率衡量 时间复杂度与大O表示法\n单靠运行时间不可信不客观：和电脑新旧，运算能力有关\n时间复杂度：描述算法时间上的效率\n 假定执行算法每一个基本操作的时间是固定的，执行的基本运算数量可以忽略机器环境的影响客观的反映算法的时间效率\n\u0026ldquo;大O表示法\u0026quot;\n\n 时间复杂度：假设存在函数g，似的算法A处理规模为n的问题实力所用的时间为T(n)=O(g(n)),则称O(g(n))为算法A的监禁时间复杂度，简称为时间复杂度，记为T(n)\n 计量算法基本操作的规模函数中的常量因子可以忽略不计\n03 最坏时间复杂度 分析算法时，存在几种可能的考虑：\n算法完成工作最少需要多少基本操作，即最优时间复杂度：没啥意义\n算法完成工作最多需要多少基本操作，即最坏时间复杂度:一种保证，通常时间复杂度就是指最坏这个\n算法完成工作平均需要多少基本操作，即平均时间复杂度：全面评价，但没有保证\n##总结：\n 基本操作，即只有常数项，认为其时间复杂度为O(1) 顺序结构，时间复杂度按加法进行计算 循环结构，时间复杂度按乘法进行计算 分支结构，时间复杂度取最大值 (比如if else) 判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略 在没有特殊说明时，我们所分析的算法的时间复杂度都是指最坏时间复杂度  最常见的时间复杂度    执行次数函数举例 阶 非正式术语     12 O(1) 常数阶   2n+3 O(n) 线性阶   $3n^2+2n+1$ $O(n^2)$ 平方阶   5log2n+20 O(logn) 对数阶   2n+3nlog2n+19 O(nlogn) nlogn阶   $6n^3+2n^2+3n+4$ $O(n^3)$ 立方阶   $2^n $ $O(2^n)$ 指数阶    注意，经常将log2n（以2为底的对数）简写成logn\n必须记住： $O(1) \u0026lt; O(logn) \u0026lt; O(n) \u0026lt; O(nlogn) \u0026lt; O(n^2)\u0026lt; O(n^2logn) \u0026lt; O(n^3) \u0026lt; O(2^n) \u0026lt; O(n!) \u0026lt; O(n^n)$\nPython 内置类型性能分析 \u0026ndash; timeit  列表生成式\nPython内置的一种极其强大的生成列表 list 的表达式。返回结果必须是列表。\n  基本语法：\n [ 变量表达式 for 变量 in 表达式 ]\n#对比四种list列表构造方式的效率 from timeit import Timer def test1(): #append() l = [] for i in range(10000): l.append(i) def test2(): #+= l = [] for i in range(10000): l += [i] def test2_1(): #+ l = [] for i in range(10000): l = l + [i] def test3(): #列表生成式 [i for i in range] l = [i for i in range(10000)] def test4(): #可迭代对象直接生成列表 list(range) l = list(range(10000)) def test5(): #extend() l = [] for i in range(10000): l.extend([i]) timer1= Timer(\u0026quot;test1()\u0026quot;,\u0026quot;from __main__ import test1\u0026quot;) print(\u0026quot;append():\u0026quot;,timer1.timeit(number=1000),\u0026quot;seconds\u0026quot;) timer2= Timer(\u0026quot;test2()\u0026quot;,\u0026quot;from __main__ import test2\u0026quot; ) print(\u0026quot;+=:\u0026quot;,timer2.timeit(number=1000),\u0026quot;seconds\u0026quot;) timer2_1= Timer(\u0026quot;test2_1()\u0026quot;,\u0026quot;from __main__ import test2_1\u0026quot; ) print(\u0026quot;+:\u0026quot;,timer2_1.timeit(number=1000),\u0026quot;seconds\u0026quot;) timer3= Timer(\u0026quot;test3()\u0026quot;,\u0026quot;from __main__ import test3\u0026quot; ) print(\u0026quot;[i for i in range]:\u0026quot;,timer3.timeit(number=1000),\u0026quot;seconds\u0026quot;) timer4= Timer(\u0026quot;test4()\u0026quot;,\u0026quot;from __main__ import test4\u0026quot; ) print(\u0026quot;list(range):\u0026quot;,timer4.timeit(number=1000),\u0026quot;seconds\u0026quot;) timer5= Timer(\u0026quot;test5()\u0026quot;,\u0026quot;from __main__ import test5\u0026quot; ) print(\u0026quot;extend():\u0026quot;,timer5.timeit(number=1000),\u0026quot;seconds\u0026quot;)  append(): 0.64611264999985 seconds +=: 0.6851804809998612 seconds +: 112.89560661899986 seconds [i for i in range]: 0.2947488119998525 seconds list(range): 0.1802340100002766 seconds extend(): 0.9059880499999053 seconds  可以看出：光用+很费时间，可以选择使用+= or extend（）替换\ninsert 和 append 比较  list.insert(pos, elmnt)\n def test1(): #append() l = [] for i in range(10000): l.append(i) #尾部添加 def test6(): #extend() l = [] for i in range(10000): l.insert(0, i) #头部添加 timer1= Timer(\u0026quot;test1()\u0026quot;,\u0026quot;from __main__ import test1\u0026quot;) print(\u0026quot;append():\u0026quot;,timer1.timeit(number=1000),\u0026quot;seconds\u0026quot;) timer6= Timer(\u0026quot;test6()\u0026quot;,\u0026quot;from __main__ import test6\u0026quot; ) print(\u0026quot;insert():\u0026quot;,timer6.timeit(number=1000),\u0026quot;seconds\u0026quot;)  append(): 0.6008801650004898 seconds insert(): 19.97815154900036 seconds  从结果可以看出，append从尾端添加元素效率远远高于insert从顶端添加元素\n原因： 由于列表list的数据存储[方式决定的\nlist内置操作的时间复杂度\nlndex:O(1) append: O(1) contain(in): O(n)查找\ndict内置操作的时间复杂度\n数据结构 算法关注的是问题的解决步骤，没有关注处理的是什么样的数据\n 我们如何用Python中的类型来保存一个班的学生信息？ 如果想要快速的通过学生姓名获取其信息呢？\n  实际上当我们在思考这个问题的时候，我们已经用到了数据结构。列表和字典都可以存储一个班的学生信息，但是想要在列表中获取一名同学的信息时，就要遍历这个列表，其时间复杂度为O(n)，而使用字典存储时，可将学生姓名作为字典的键，学生信息作为值，进而查询时不需要遍历便可快速获取到学生信息，其时间复杂度为O(1)\n概念\n 数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。\n简而言之：一组数据如何保存\n基本数据类型： float、int, char\u0026hellip;\n所以list， dict\u0026hellip;已经是一种高级的数据结构了\n算法与数据结构的区别 程序 = 数据结构 + 算法\n算法：为解决实际问题设计的\n数据结构： 算法处理问题的载体\n抽象数据类型(ADT：Abstract Data Type) 定义：一个数学模型以及定义在此数学模型上的一组操作\n例子：\n先规定好数据如何保存（数据结构），定义这些数据结构支持的操作（具体怎么实现不去管）\nclass students(object): def adds def pop def sort def ...  a = [1, 2] a *=10 print(a)  [1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2]  ","date":1587772800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587772800,"objectID":"29094b33bc0ac19f93665bdb584af73f","permalink":"https://jianzhang6.github.io/blog/data-structure/%E7%AC%94%E8%AE%B0/01/","publishdate":"2020-04-25T00:00:00Z","relpermalink":"/blog/data-structure/%E7%AC%94%E8%AE%B0/01/","section":"blog","summary":"数据结构与算法笔记01","tags":["Note"],"title":"01 引入概念","type":"blog"},{"authors":["Jian Zhang"],"categories":["data structure"],"content":"根据线性表的实际存储方式，分为两种实现模型：\n顺序表 :将元素顺序地存放在一块连续的存储区里，元素间的顺序关系由它们的存储顺序自然表示。\n链表 :将元素存放在通过链接构造起来的一系列存储块中\n内存， 类型本质， 连续储存 内存是：以字节Byte为基本单位（1个字节有8位）连续的存储空间\n普通整型Int：需要4个字节（对于32位机器）\n例子： Int a = 1: 二进制 0000 0001 （只有一个字节），但是Int 占4个字节，所以还有三个字节是 0000 0000\n字符串Char： 需要1个字节\n所以：变量类型不同，需要的存储空间不同；计算机对二进制数据的方式不同\n一组相同类型数据最简单的存储方式： 顺序表连续存储\n顺序表的基本形式 基本顺序表只能处理相同类型\n元素外置的顺序表可以存储不同类型的数据，因为物理地址所占的大小是一样的（连续空间储存地址）\n顺序表的结构与实现 一个顺序表的完整信息包括两部分，一部分是为实现正确操作而需记录的信息，即有关表的整体情况的信息，这部分信息主要包括元素存储区的容量和当前表中已有的元素个数两项；另一部分是表中的元素集合\n顺序表的两种基本实现方式  图a为一体式结构，存储表信息的单元与元素存储区以连续的方式安排在一块存储区里，两部分数据的整体形成一个完整的顺序表对象。 图b为分离式结构，表对象里只保存与整个表有关的信息（即容量和元素个数），实际数据元素存放在另一个独立的元素存储区里，通过链接与基本表对象关联。  一体式结构整体性强，易于管理。但是由于数据元素存储区域是表对象的一部分，顺序表创建后，元素存储区就固定了。\n元素存储区替换  一体式结构由于顺序表信息区与数据区连续存储在一起，所以若想更换数据区，则只能整体搬迁，即整个顺序表对象（指存储顺序表的结构信息的区域）改变了。\n分离式结构若想更换数据区，只需将表信息区中的数据区链接地址更新即可，而该顺序表对象不变。\n元素存储区扩充 可以扩充的分离式结构顺序表： 动态顺序表\n扩充策略：\n  线性增长：每次扩充固定树木的存储位置\n节省空间，操作频繁\n  加倍增长： 每次扩充容量加倍\n减少操作次数， 可能浪费空间资源，以空间换时间（推荐）\n  顺序表的操作 增加元素 a. 尾端加入元素，时间复杂度为O(1)\nb. 非保序（顺序可变）的加入元素（不常见），时间复杂度为O(1)\nc. 保序（顺序不可变）的元素加入，时间复杂度为O(n)\n删除元素 a. 删除表尾元素，时间复杂度为O(1)\nb. 非保序的元素删除（不常见），时间复杂度为O(1)\nc. 保序的元素删除，时间复杂度为O(n)\nPython中的顺序表 Python中的list和tuple两种类型采用了顺序表的实现技术，具有前面讨论的顺序表的所有性质。\ntuple不可以修改，其他与list的性质类似。\nlist的基本实现技术 基于下标（位置）的高效元素访问和更新，时间复杂度应该是O(1)；\n为满足该特征，应该采用顺序表技术，表中元素保存在一块连续的存储区中。\n允许任意加入元素，而且在不断加入元素的过程中，表对象的标识（函数id得到的值）不变\n为满足该特征，就必须能更换元素存储区，并且为保证更换存储区时list对象的标识id不变，只能采用分离式实现技术。\n在Python的官方实现中，list就是一种采用分离式技术实现的动态顺序表。这就是为什么用list.append(x) （或 list.insert(len(list), x)，即尾部插入）比在指定位置插入元素效率高的原因。\n  ","date":1587772800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587772800,"objectID":"20ad962e9213be5dc9bee253aadf5bba","permalink":"https://jianzhang6.github.io/blog/data-structure/%E7%AC%94%E8%AE%B0/02/","publishdate":"2020-04-25T00:00:00Z","relpermalink":"/blog/data-structure/%E7%AC%94%E8%AE%B0/02/","section":"blog","summary":"数据结构与算法笔记02","tags":["Note"],"title":"02 顺序表","type":"blog"},{"authors":["Jian Zhang"],"categories":["data structure"],"content":"链表 链表和顺序表统称为线性表：物理储存\n区别是：\n 顺序表：连续的储存 链表：离散的储存  为什么需要链表 顺序表的构建需要预先知道数据大小来申请连续的存储空间，而在进行扩充时又需要进行数据的搬迁，所以使用起来并不是很灵活。\n链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。\n链表的定义 链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是不像顺序表一样连续存储数据，而是在每一个节点（数据存储单元）里存放下一个节点的位置信息（即地址）。\n单向链表 单向链表也叫单链表，是链表中最简单的一种形式，它的每个节点包含两个域，一个信息域（元素域）和一个链接域。这个链接指向链表中的下一个节点，而最后一个节点的链接域则指向一个空值。\nP表示第一个节点的位置\n 变量p指向链表的头节点（首节点）的位置，从p出发能找到表中的任意节点。 表元素域elem用来存放具体的数据。 链接域next用来存放下一个节点的位置（python中的标识）  单链表的操作  is_empty() 链表是否为空\nlength() 链表长度\ntravel() 遍历整个链表\nadd(item) 链表头部添加元素\nappend(item) 链表尾部添加元素\ninsert(pos, item) 指定位置添加元素\nremove(item) 删除节点\nsearch(item) 查找节点是否存在\n 注意:Python 中的变量名保存的是对象的地址 而不是对象本身\n# 节点实现 class SingleNode(object): \u0026quot;\u0026quot;\u0026quot;单链表的结点\u0026quot;\u0026quot;\u0026quot; def __init__(self, item): # item存放数据元素 self.item = item # next是下一个节点的标识,因未知所以设为空None self.next = None  #单链表的实现 class SingleLinkList(object): \u0026quot;单链表\u0026quot; def __init__(self, node=None): \u0026quot;链表头\u0026quot; self.__head = None #_表示私有 def is_empty(self): \u0026quot;链表是否为空\u0026quot; return self.__head == None #将head是否指向None作为return的结果 def length(self): \u0026quot;链表长度\u0026quot; # cur初始时指向头节点，用来移动遍历节点 cur = self.__head count = 0 # 尾节点指向None，当未到达尾部时 while cur != None: count += 1 # 将cur后移一个节点 cur = cur.next return count def travel(self): \u0026quot;遍历整个链表\u0026quot; cur = self.__head while cur != None: print(cur.item, end=\u0026quot; \u0026quot;) cur = cur.next print(\u0026quot;\u0026quot;) #换行 def append(self, item): \u0026quot;链表尾部添加元素\u0026quot; node = SingleNode(item) # 先判断链表是否为空，若是空链表，则将_head指向新节点node if self.is_empty(): self.__head = node # 若不为空，则找到尾部，将尾节点的next指向新节点 else: cur = self.__head while cur.next != None: cur = cur.next cur.next = node def add(self, item): \u0026quot;链表头部添加元素\u0026quot; # 先创建一个保存item值的节点 node = SingleNode(item) # 将新节点的链接域next指向头节点，即_head指向的位置 node.next = self.__head # 将链表的头_head指向新节点 self.head = node def insert(self, pos, item): \u0026quot;指定位置添加元素\u0026quot; if pos \u0026lt;= 0: self.add(item) elif pos \u0026gt; (self.length()-1): self.append(item) else: node = SingleNode(item) # pre用来指向指定位置pos的前一个位置pos-1，初始从头节点开始移动到指定位置 pre = self.__head count = 0 while count \u0026lt; (pos-1): count += 1 pre = pre.next # 先将新节点node的next指向插入位置的节点 node.next = pre.next # 将插入位置的前一个节点的next指向新节点 pre.next = node #不是pre = node，是pre节点的next区域变成node def search(self, item): \u0026quot;查找节点是否存在，并返回True或者False\u0026quot; node = SingleNode(item) cur = self.__head while cur != None: if cur == node: return True else: cur = cur.next return False def remove(self, item): \u0026quot;删除节点\u0026quot; cur = self.__head pre = None while cur != None: if cur.item == item: # 如果第一个就是删除的节点 if cur == self.__head: # 将头指针指向头节点的后一个节点 self.__head = cur.next else: # 将删除位置前一个节点的next指向删除位置的后一个节点 pre.next = cur.next break else: pre = cur cur = cur.next  #----测试----- # 节点 class SingleNode(object): \u0026quot;\u0026quot;\u0026quot;单链表的结点\u0026quot;\u0026quot;\u0026quot; def __init__(self, item): # item存放数据元素 self.item = item # next是下一个节点的标识,因未知所以设为空None self.next = None # 单链表 class SingleLinkList(object): \u0026quot;单链表\u0026quot; def __init__(self, node=None): \u0026quot;链表头\u0026quot; self.__head = None #_表示私有 def is_empty(self): \u0026quot;链表是否为空\u0026quot; return self.__head == None #将head是否指向None作为return的结果 def length(self): \u0026quot;链表长度\u0026quot; # cur初始时指向头节点，用来移动遍历节点 cur = self.__head count = 0 # 尾节点指向None，当未到达尾部时 while cur != None: count += 1 # 将cur后移一个节点 cur = cur.next return count def travel(self): \u0026quot;遍历整个链表\u0026quot; cur = self.__head while cur != None: print(cur.item, end=\u0026quot; \u0026quot;) cur = cur.next print(\u0026quot;\u0026quot;) def append(self, item): \u0026quot;链表尾部添加元素\u0026quot; node = SingleNode(item) # 先判断链表是否为空，若是空链表，则将_head指向新节点node if self.is_empty(): self.__head = node # 若不为空，则找到尾部，将尾节点的next指向新节点 else: cur = self.__head while cur.next != None: cur = cur.next cur.next = node def add(self, item): \u0026quot;链表头部添加元素\u0026quot; # 先创建一个保存item值的节点 node = SingleNode(item) # 将新节点的链接域next指向头节点，即_head指向的位置 node.next = self.__head # 将链表的头_head指向新节点 self.__head = node def insert(self, pos, item): \u0026quot;指定位置添加元素\u0026quot; if pos \u0026lt;= 0: self.add(item) elif pos \u0026gt; (self.length()-1): self.append(item) else: node = SingleNode(item) # pre用来指向指定位置pos的前一个位置pos-1，初始从头节点开始移动到指定位置 pre = self.__head count = 0 while count \u0026lt; (pos-1): count += 1 pre = pre.next # 先将新节点node的next指向插入位置的节点 node.next = pre.next # 将插入位置的前一个节点的next指向新节点 pre.next = node #不是pre = node，是pre节点的next区域变成node def search(self, item): \u0026quot;查找节点是否存在，并返回True或者False\u0026quot; cur = self.__head while cur != None: if cur.item == item: return True else: cur = cur.next return False def remove(self, item): \u0026quot;删除节点\u0026quot; cur = self.__head pre = None while cur != None: if cur.item == item: # 如果第一个就是删除的节点 if cur == self.__head: # 将头指针指向头节点的后一个节点 self.__head = cur.next else: # 将删除位置前一个节点的next指向删除位置的后一个节点 pre.next = cur.next break else: pre = cur cur = cur.next #测试 if __name__ == \u0026quot;__main__\u0026quot;: ll = SingleLinkList() print(ll.is_empty()) print(ll.length()) ll.append(1) print(ll.is_empty()) print(ll.length()) ll.add(9) ll.append(2) ll.append(3) ll.append(4) ll.insert(-1,100) ll.travel() ll.insert(100,200) ll.travel() ll.insert(3,8) ll.travel() ll.search(100) ll.remove(100) ll.travel() ll.remove(1) ll.travel() ll.remove(200) ll.travel()  True 0 False 1 100 9 1 2 3 4 100 9 1 2 3 4 200 100 9 1 8 2 3 4 200 9 1 8 2 3 4 200 9 8 2 3 4 200 9 8 2 3 4  链表与顺序表的对比    操作 链表 顺序表     访问元素 search O(n) O(1)   在头部插入/删除 add O(1) O(n)   在尾部插入/删除 append O(n) O(1)   在中间插入/删除 insert O(n) O(n)    while循环：O(n), 链表只记录头节点，访问需要遍历\n注意虽然表面看起来复杂度都是 O(n)，但是链表和顺序表在插入和删除时进行的是完全不同的操作。链表的主要耗时操作是遍历查找，删除和插入操作本身的复杂度是O(1)。顺序表查找很快，主要耗时的操作是拷贝覆盖。因为除了目标元素在尾部的特殊情况，顺序表进行插入和删除时需要对操作点之后的所有元素进行前后移位操作，只能通过拷贝和覆盖的方法进行。\n顺序表：\n 优点：存取元素的时候复杂度O(1)，一次性并类 缺点：需要连续的整块内存 在中间插入/删除 insert O(n):花费在数据搬迁  链表：\n 优点：可以使用分散的可用内存 缺点：储存空间需要更大，除了原有数据还要存地址指针，存取元素的时候复杂度O(n) 在中间插入/删除 insert O(n):花费在遍历  双向链表 双向链表结构分析 一种更复杂的链表是“双向链表”或“双面链表”。每个节点有两个链接：一个指向前一个节点，当此节点为第一个节点时，指向空值；而另一个指向下一个节点，当此节点为最后一个节点时，指向空值。\n除了后继节点：.next, 多一个前驱节点：.prev\n双链表操作  is_empty() 链表是否为空\nlength() 链表长度\ntravel() 遍历链表\nadd(item) 链表头部添加\nappend(item) 链表尾部添加\ninsert(pos, item) 指定位置添加\nremove(item) 删除节点\nsearch(item) 查找节点是否存在\n # 节点实现 class Node(object): \u0026quot;\u0026quot;\u0026quot;双链表的结点\u0026quot;\u0026quot;\u0026quot; def __init__(self, item): # item存放数据元素 self.item = item # 后继节点 next self.next = None #前驱节点 prev self.prev = None  # 双向链表的实现 class DoubleLinkList(object): \u0026quot;双链表\u0026quot; def __init__(self, node=None): \u0026quot;链表头\u0026quot; self.__head = None def is_empty(self): \u0026quot;链表是否为空--一样\u0026quot; return self.__head is None #将head是否指向None作为return的结果 def length(self): \u0026quot;链表长度--一样\u0026quot; # cur初始时指向头节点，用来移动遍历节点 cur = self.__head count = 0 # 尾节点指向None，当未到达尾部时 while cur != None: count += 1 # 将cur后移一个节点 cur = cur.next return count def travel(self): \u0026quot;遍历整个链表--一样\u0026quot; cur = self.__head while cur != None: print(cur.item, end=\u0026quot; \u0026quot;) cur = cur.next print(\u0026quot;\u0026quot;) def search(self, item): \u0026quot;查找节点是否存在，并返回True或者False--一样\u0026quot; cur = self.__head while cur != None: if cur.item == item: return True else: cur = cur.next return False #-----有变化---- def append(self, item): \u0026quot;链表尾部添加元素\u0026quot; node = Node(item) # 先判断链表是否为空，若是空链表，则将_head指向新节点node if self.is_empty(): self.__head = node # 若不为空，则找到尾部，将尾节点的next指向新节点 else: cur = self.__head while cur.next != None: cur = cur.next cur.next = node node.prev = cur def add(self, item): \u0026quot;链表头部添加元素\u0026quot; # 先判断链表是否为空，若是空链表，则将_head指向新节点node if self.is_empty(): self.__head = node else: # 先创建一个保存item值的节点 node = Node(item) # 将新节点的链接域next指向头节点，即_head指向的位置 node.next = self.__head # 将链表的头_head指向新节点 self.__head = node node.next.prev = node #---也可以是这样：2-3注意循序 # node.next = self.__head # self.__head.prev= node # self.__head = node #def add(self, item): # \u0026quot;\u0026quot;\u0026quot;头部插入元素\u0026quot;\u0026quot;\u0026quot; # node = Node(item) # if self.is_empty(): # # 如果是空链表，将_head指向node # self.__head = node # else: # # 将node的next指向_head的头节点 # node.next = self.__head # # 将_head的头节点的prev指向node # self.__head.prev = node # # 将_head 指向node # self.__head = node def insert(self, pos, item): \u0026quot;指定位置添加元素\u0026quot; if pos \u0026lt;= 0: self.add(item) elif pos \u0026gt; (self.length()-1): self.append(item) else: node = Node(item) cur = self.__head #cur指向pos位置 count = 0 while count \u0026lt; pos: count += 1 cur = cur.next # 将node的next指向cur node.next = cur # 将node的prev指向cur的prev node.prev = cur.prev # 将cur的prev的指向node cur.prev = node # 将cur的prev的下一个节点指向node cur.prev.next = node def remove(self, item): \u0026quot;删除节点\u0026quot; cur = self.__head while cur != None: # 找到了要删除的元素 if cur.item == item: # 先判断此结点是否是首节点 if cur == self.__head: # 删除首节点 self.__head = cur.next if cur.next: # 判断链表是否只有一个节点，即cur.next != None cur.next.prev = None else: # 删除非首节点（一般情况） cur.prev.next = cur.next if cur.next: # 判断链表是否是最后一个节点 cur.next.prev = cur.prev break else: cur = cur.next  #----测试---- # 节点实现 class Node(object): \u0026quot;\u0026quot;\u0026quot;双链表的结点\u0026quot;\u0026quot;\u0026quot; def __init__(self, item): # item存放数据元素 self.item = item # 后继节点 next self.next = None #前驱节点 prev self.prev = None # 双向链表的实现 class DoubleLinkList(object): \u0026quot;双链表\u0026quot; def __init__(self,node=None): \u0026quot;链表头\u0026quot; self.__head = None def is_empty(self): \u0026quot;链表是否为空--一样\u0026quot; return self.__head is None #将head是否指向None作为return的结果 def length(self): \u0026quot;链表长度--一样\u0026quot; # cur初始时指向头节点，用来移动遍历节点 cur = self.__head count = 0 # 尾节点指向None，当未到达尾部时 while cur != None: count += 1 # 将cur后移一个节点 cur = cur.next return count def travel(self): \u0026quot;遍历整个链表--一样\u0026quot; cur = self.__head while cur != None: print(cur.item, end=\u0026quot; \u0026quot;) cur = cur.next print(\u0026quot;\u0026quot;) def search(self, item): \u0026quot;查找节点是否存在，并返回True或者False--一样\u0026quot; cur = self.__head while cur != None: if cur.item == item: return True else: cur = cur.next return False #-----有变化---- def append(self, item): \u0026quot;链表尾部添加元素\u0026quot; node = Node(item) # 先判断链表是否为空，若是空链表，则将_head指向新节点node if self.is_empty(): self.__head = node # 若不为空，则找到尾部，将尾节点的next指向新节点 else: cur = self.__head while cur.next != None: cur = cur.next cur.next = node node.prev = cur def add(self, item): \u0026quot;链表头部添加元素\u0026quot; # 先判断链表是否为空，若是空链表，则将_head指向新节点node if self.is_empty(): self.__head = node else: # 先创建一个保存item值的节点 node = Node(item) # 将新节点的链接域next指向头节点，即_head指向的位置 node.next = self.__head # 将链表的头_head指向新节点 self.__head = node node.next.prev = node #---也可以是这样：2-3注意循序 # node.next = self.__head # self.__head.prev= node # self.__head = node #def add(self, item): # \u0026quot;\u0026quot;\u0026quot;头部插入元素\u0026quot;\u0026quot;\u0026quot; # node = Node(item) # if self.is_empty(): # # 如果是空链表，将_head指向node # self.__head = node # else: # # 将node的next指向_head的头节点 # node.next = self.__head # # 将_head的头节点的prev指向node # self.__head.prev = node # # 将_head 指向node # self.__head = node def insert(self, pos, item): \u0026quot;指定位置添加元素\u0026quot; if pos \u0026lt;= 0: self.add(item) elif pos \u0026gt; (self.length()-1): self.append(item) else: node = Node(item) cur = self.__head #cur指向pos位置 count = 0 while count \u0026lt; pos: count += 1 cur = cur.next # 将node的next指向cur node.next = cur # 将node的prev指向cur的prev node.prev = cur.prev # 将cur的prev的指向node cur.prev = node # 将cur的prev的下一个节点指向node cur.prev.next = node def remove(self, item): \u0026quot;删除节点\u0026quot; cur = self.__head while cur != None: # 找到了要删除的元素 if cur.item == item: # 先判断此结点是否是首节点 if cur == self.__head: # 删除首节点 self.__head = cur.next if cur.next: # 判断链表是否只有一个节点，即cur.next != None cur.next.prev = None else: # 删除非首节点（一般情况） cur.prev.next = cur.next if cur.next: # 判断链表是否是最后一个节点 cur.next.prev = cur.prev break else: cur = cur.next #测试 if __name__ == \u0026quot;__main__\u0026quot;: dll = DoubleLinkList() print(dll.is_empty()) print(dll.length()) dll.append(1) print(dll.is_empty()) print(dll.length()) dll.add(9) dll.append(2) dll.append(3) dll.append(4) dll.insert(-1,100) dll.travel() dll.insert(100,200) dll.travel() dll.insert(3,8) dll.travel() dll.search(100) dll.remove(100) dll.travel() dll.remove(1) dll.travel() dll.remove(200) dll.travel()  True 0 False 1 100 9 1 2 3 4 100 9 1 2 3 4 200 100 9 1 2 3 4 200 9 1 2 3 4 200 9 2 3 4 200 9 2 3 4  单向循环链表 单向循环链表的结构 单链表的一个变形是单向循环链表，链表中最后一个节点的next域不再为None，而是指向链表的头节点。\n单向循环链表的操作  is_empty() 链表是否为空\nlength() 链表长度\ntravel() 遍历整个链表\nadd(item) 链表头部添加元素\nappend(item) 链表尾部添加元素\ninsert(pos, item) 指定位置添加元素\nremove(item) 删除节点\nsearch(item) 查找节点是否存在\n #----code含测试----- # 节点 class SingleNode(object): def __init__(self, item): self.item = item self.next = None # 单向循环链表 class SinCycLinkedList(object): \u0026quot;单向循环链表\u0026quot; def __init__(self, node=None): self.__head = None if node: # 判断node是否是None node.next = node def is_empty(self): \u0026quot;链表是否为空--一样\u0026quot; return self.__head == None # 将head是否指向None作为return的结果 def length(self): \u0026quot;链表长度\u0026quot; # 如果链表为空，返回长度0 if self.is_empty(): return 0 cur = self.__head count = 1 while cur.next != self.__head: count += 1 cur = cur.next return count def travel(self): \u0026quot;遍历整个链表\u0026quot; if self.is_empty(): # 空链表，退出不做任何操作 return cur = self.__head while cur.next != self.__head: print(cur.item, end=\u0026quot; \u0026quot;) cur = cur.next # 退出循环，cur指向尾节点，但是未被打印 print(cur.item) print(\u0026quot;\u0026quot;) def add(self, item): \u0026quot;链表头部添加元素\u0026quot; node = SingleNode(item) if self.is_empty(): self.__head = node node.next = node else: cur = self.__head while cur.next != self.__head: cur = cur.next # 将新节点的链接域next指向头节点，即_head指向的位置 node.next = self.__head # 将链表的头_head指向新节点 self.__head = node cur.next = node def append(self, item): \u0026quot;链表尾部添加元素\u0026quot; node = SingleNode(item) if self.is_empty(): self.__head = node node.next = node else: cur = self.__head while cur.next != self.__head: cur = cur.next cur.next = node node.next = self.__head def insert(self, pos, item): \u0026quot;指定位置添加元素--一样\u0026quot; if pos \u0026lt;= 0: self.add(item) elif pos \u0026gt; (self.length()-1): self.append(item) else: node = SingleNode(item) # pre用来指向指定位置pos的前一个位置pos-1，初始从头节点开始移动到指定位置 pre = self.__head count = 0 while count \u0026lt; (pos-1): count += 1 pre = pre.next # 先将新节点node的next指向插入位置的节点 node.next = pre.next # 将插入位置的前一个节点的next指向新节点 pre.next = node #不是pre = node，是pre节点的next区域变成node def search(self, item): \u0026quot;查找节点是否存在，并返回True或者False\u0026quot; if self.is_empty(): return False cur = self.__head if cur.item == item: return True while cur.next != self.__head: if cur.item == item: return True else: cur = cur.next # 退出循环，cur指向尾节点 return False def remove(self, item): \u0026quot;删除节点\u0026quot; if self.is_empty(): return cur = self.__head pre = None while cur.next != self.__head: if cur.item == item: if cur == self.__head: # 头节点 rear = self.__head #找尾节点 while rear.next != self.__head: rear = rear.next self.__head = cur.next rear.next = self.__head else: # 中间节点 pre.next = cur.next return # 不是break # break是跳出一层循环，continue是结束一趟循环 else: pre = cur cur = cur.next # 退出循环，cur指向尾节点 if cur.item == item: if cur == self.__head: # 链表只有一个节点 self.__head = None else: pre.next = cur.next # 等于 pre.next = self.__head #测试 if __name__ == \u0026quot;__main__\u0026quot;: ll = SinCycLinkedList() print(ll.is_empty()) print(ll.length()) ll.append(1) print(ll.is_empty()) print(ll.length()) ll.add(9) ll.append(2) ll.append(3) ll.append(4) ll.insert(-1,100) ll.travel() ll.insert(100,200) ll.travel() ll.insert(3,8) ll.travel() ll.search(1000) ll.remove(100) ll.travel() ll.remove(1) ll.travel() ll.remove(200) ll.travel()  True 0 False 1 100 9 1 2 3 4 100 9 1 2 3 4 200 100 9 1 8 2 3 4 200 9 1 8 2 3 4 200 9 8 2 3 4 200 9 8 2 3 4  栈线性表的区别：栈描述怎么操作，线性表描述怎么存放\n栈和队列（下一节）：这两种数据结构不用考虑他们在物理上是怎样储存的， 只需要关心支持什么样的操作，操作有什么特点\n栈 Stack 栈（stack），有些地方称为堆栈，是一种容器，可存入数据元素、访问元素、删除元素，它的特点在于只能允许在容器的一端（称为栈顶端指标，英语：top）进行加入数据（英语：push）和输出数据（英语：pop）的运算。没有了位置概念，保证任何时候可以访问、删除的元素都是此前最后存入的那个元素，确定了一种默认的访问顺序。\n由于栈数据结构只允许在一端进行操作，因而按照后进先出“最后一个进来的第一个先出去”（LIFO, Last In First Out）的原理运作。\n像是一个杯子，只有一个口：先加的跑到杯底，倒出的时候杯口先出来\n栈结构和实现 栈的操作  Stack() 创建一个新的空栈\npush(item) 添加一个新的元素item到栈顶\npop() 弹出栈顶元素\npeek() 返回栈顶元素\nis_empty() 判断栈是否为空\nsize() 返回栈的元素个数\n class Stack(object): \u0026quot;栈\u0026quot; def __init__(self): self.items = [] def is_empty(self): \u0026quot;判断是否为空\u0026quot; return self.items == [] # return not self.item #逻辑上为假: \u0026quot;\u0026quot;, [], {},(), def push(self, item): \u0026quot;加入元素\u0026quot; self.items.append(item) def pop(self): \u0026quot;弹出元素\u0026quot; return self.items.pop() def peek(self): \u0026quot;返回栈顶元素\u0026quot; if self.items: return self.items[len(self.items)-1] else: return None def size(self): \u0026quot;返回栈的大小\u0026quot; return len(self.items) if __name__ == \u0026quot;__main__\u0026quot;: stack = Stack() stack.push(\u0026quot;hello\u0026quot;) stack.push(\u0026quot;world\u0026quot;) stack.push(\u0026quot;itcast\u0026quot;) print(stack.size()) print(stack.peek()) print(stack.pop()) print(stack.pop()) print(stack.pop())  3 itcast itcast world hello  队列 队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。\n队列是一种先进先出的（First In First Out）的线性表，简称FIFO。允许插入的一端为队尾，允许删除的一端为队头。队列不允许在中间部位进行操作！假设队列是q=（a1，a2，……，an），那么a1就是队头元素，而an是队尾元素。这样我们就可以删除时，总是从a1开始，而插入时，总是在队列最后。这也比较符合我们通常生活中的习惯，排在第一个的优先出列，最后来的当然排在队伍最后。\n操作  Queue() 创建一个空的队列\nenqueue(item) 往队列中添加一个item元素\ndequeue() 从队列头部删除一个元素\nis_empty() 判断一个队列是否为空\nsize() 返回队列的大小\n class Queue(object): \u0026quot;队列\u0026quot; def __init__(self): self.items = [] def is_empty(self): return self.items == [] def enqueue(self, item): \u0026quot;进队列\u0026quot; self.items.insert(0,item)# 尾部添加 #self.item.append(item) # 头部添加 def dequeue(self): \u0026quot;出队列\u0026quot; return self.items.pop() # 尾部弹出 # return self.items.pop(0) # 头部弹出 def size(self): \u0026quot;返回大小\u0026quot; return len(self.items) if __name__ == \u0026quot;__main__\u0026quot;: q = Queue() q.enqueue(\u0026quot;hello\u0026quot;) q.enqueue(\u0026quot;world\u0026quot;) q.enqueue(\u0026quot;itcast\u0026quot;) print(q.size()) print(q.dequeue()) print(q.dequeue()) print(q.dequeue())  3 hello world itcast  双端队列 双端队列（deque，全名double-ended queue），是一种具有队列和栈的性质的数据结构。\n双端队列中的元素可以从两端弹出，其限定插入和删除操作在表的两端进行。双端队列可以在队列任意一端入队和出队。\n双端队列：相当于两个栈底部合到一起\n操作  Deque() 创建一个空的双端队列\nadd_front(item) 从队头加入一个item元素\nadd_rear(item) 从队尾加入一个item元素\nremove_front() 从队头删除一个item元素\nremove_rear() 从队尾删除一个item元素\nis_empty() 判断双端队列是否为空\nsize() 返回队列的大小\n return 会直接另函数返回，函数就运行结束了，所有该函数体内的代码都不再执行了，所以该函数体内的循环也不可能再继续运行。\n如果你需要让循环继续执行，就不能return函数，而应该选用break或者continue。\nbreak：跳出所在的当前整个循环，到外层代码继续执行。\ncontinue：跳出本次循环，从下一个迭代继续运行循环，内层循环执行完毕，外层代码继续运行。\nreturn：直接返回函数，所有该函数体内的代码（包括循环体）都不会再执行。\nclass Deque(object): \u0026quot;双端队列\u0026quot; def __init__(self): self.items = [] def is_empty(self): \u0026quot;判断队列是否为空\u0026quot; return self.items == [] def add_front(self, item): \u0026quot;在队头添加元素\u0026quot; self.items.insert(0,item) def add_rear(self, item): \u0026quot;在队尾添加元素\u0026quot; self.items.append(item) def remove_front(self): \u0026quot;从队头删除元素\u0026quot; return self.items.pop(0) def remove_rear(self): \u0026quot;从队尾删除元素\u0026quot; return self.items.pop() def size(self): \u0026quot;返回队列大小\u0026quot; return len(self.items) if __name__ == \u0026quot;__main__\u0026quot;: deque = Deque() deque.add_front(1) deque.add_front(2) deque.add_rear(3) deque.add_rear(4) print(deque.size()) print(\u0026quot;deque:\u0026quot;, 2, 1, 3, 4) print(deque.remove_front()) print(deque.remove_front()) print(deque.remove_rear()) print(deque.remove_rear())  4 deque: 2 1 3 4 2 1 4 3  ","date":1587772800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587772800,"objectID":"52556a8196fb8a5cd5f87633a11f8320","permalink":"https://jianzhang6.github.io/blog/data-structure/%E7%AC%94%E8%AE%B0/03/","publishdate":"2020-04-25T00:00:00Z","relpermalink":"/blog/data-structure/%E7%AC%94%E8%AE%B0/03/","section":"blog","summary":"数据结构与算法笔记03","tags":["Note"],"title":"03 链表栈队列","type":"blog"},{"authors":["Jian Zhang"],"categories":["data structure"],"content":"排序算法的稳定性 排序算法（英语：Sorting algorithm）是一种能将一串数据依照特定顺序进行排列的一种算法。\n稳定性：稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。\n当相等的元素是无法分辨的，比如像是整数，稳定性并不是一个问题。然而，假设以下的数对将要以他们的第一个数字来排序。\n常见排序算法效率比较 冒泡排序 Bubble Sort 冒泡排序算法的运作如下：\n比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\ndef bubble_sort(alist): #自己写的！ for j in range(len(alist)-1, 0, -1): for i in range(j): if alist[i] \u0026gt; alist[i+1]: alist[i], alist[i+1] = alist[i+1], alist[i] li = [54,26,93,17,77,31,44,55,20] bubble_sort(li) print(li)  [17, 20, 26, 31, 44, 54, 55, 77, 93]  #优化：如果给的就是从大到小排好的数列 def bubble_sort(alist): for j in range(len(alist)-1,0,-1): # j表示每次遍历需要比较的次数，是逐渐减小的 count = 0 for i in range(j): if alist[i] \u0026gt; alist[i+1]: alist[i], alist[i+1] = alist[i+1], alist[i] count += 1 if count == 0: return alist li = [1,2,3,4,5] bubble_sort(li) print(li)  [1, 2, 3, 4, 5]  时间复杂度  最优时间复杂度：O(n) 最坏时间复杂度：O($n^2$) 稳定性：稳定  选择排序（Selection sort） 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\ndef selection_sort(alist): n = len(alist) # 需要进行n-1次选择操作 for i in range(n-1): # 记录最小位置 min_index = i # 从i+1位置到末尾选择出最小数据 for j in range(i+1, n): if alist[j] \u0026lt; alist[min_index]: min_index = j # 如果选择出的数据不在正确位置，进行交换 if min_index != i: alist[i], alist[min_index] = alist[min_index], alist[i] alist = [54,226,93,17,77,31,44,55,20] selection_sort(alist) print(alist)  时间复杂度  最优时间复杂度：O($n^2$) 最坏时间复杂度：O($n^2$) 稳定性：不稳定（考虑升序每次选择最大的情况）  li=[$10_1$, 4, 5, 7, $10_2$, 9] 每次选最大值排到队尾\n排完： li=[4, 5, 7, 9, $10_2$,$10_1$]\n$10_1$, $10_2$位置和原来的位置不一样了，故不稳定\n插入排序（Insertion Sort） 它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。\ndef insert_sort(alist): for i in range(1, len(alist)): # 从第二个位置，即下标为1的元素开始向前插入 for j in range(i, 0, -1): # 从第i个元素开始向前比较，如果小于前一个元素，交换位置: # i, i-1,i-2...1 if alist[j] \u0026lt; alist[j-1]: alist[j], alist[j-1] = alist[j-1], alist[j] alist = [54,26,93,17,77,31,44,55,20] insert_sort(alist) print(alist)  [17, 20, 26, 31, 44, 54, 55, 77, 93]  # 优化 def insert_sort(alist): for i in range(1, len(alist)): # 从第二个位置，即下标为1的元素开始向前插入 j = i while j \u0026gt; 0: # 从第i个元素开始向前比较，如果小于前一个元素，交换位置: # i, i-1,i-2...1 if alist[j] \u0026lt; alist[j-1]: alist[j], alist[j-1] = alist[j-1], alist[j] j -= 1 else: break alist = [54,26,93,17,77,31,44,55,20] insert_sort(alist) print(alist)  [17, 20, 26, 31, 44, 54, 55, 77, 93]  时间复杂度  最优时间复杂度：O(n) 升序排列，有序升序数列 最坏时间复杂度：O($n^2$) 稳定性：稳定  希尔排序(Shell Sort) 插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。\ndef shell_sort(alist): \u0026quot;希尔排序\u0026quot; n = len(alist) gap = n // 2 while gap \u0026gt; 0: #gap==1 插入排序 #希尔和插入算法非常像，把i换为gap for j in range(gap, n): i = j while i\u0026gt;0: if alist[i] \u0026lt; alist[i - gap]: alist[i], alist[i-gap] = alist[i-gap], alist[i] i -= gap else: break #缩短gap步长 gap //= 2 #/是精确除法，//是向下取整除法，%是求模 alist = [54,26,93,17,77,31,44,55,20] insert_sort(alist) print(alist)  [17, 20, 26, 31, 44, 54, 55, 77, 93]  def insert_sort(alist): \u0026quot;插入排序\u0026quot; n = len(alist) # 从右边无序序列去多少个元素执行这样的过程 for j in range(1, n): # j = [1,2,3...,n-1], # i 内层循环起始值 i = j # 从第i个元素开始向前比较，如果小于前一个元素，交换位置: while i \u0026gt;0: if alist[i] \u0026lt; alist[i-1]: alist[i], alist[i-1] = alist[i-1], alist[i] i -= 1 else: break alist = [54,26,93,17,77,31,44,55,20] insert_sort(alist) print(alist)  [17, 20, 26, 31, 44, 54, 55, 77, 93]  时间复杂度  最优时间复杂度：跟序列的不同而不同而不同 最坏时间复杂度：O($n^2$) ，即gap为1，插入排序 稳定性：不稳定  快速排序（Quicksort）必须掌握 快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n步骤为：\n从数列中挑出一个元素，称为\u0026quot;基准\u0026rdquo;（pivot）， 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。\ndef quick_sort(alist, start, end): \u0026quot;\u0026quot;\u0026quot;快速排序\u0026quot;\u0026quot;\u0026quot; # 递归的退出条件 if start \u0026gt;= end: return # 设定起始元素为要寻找位置的基准元素 mid = alist[start] # low为序列左边的由左向右移动的游标 low = start # high为序列右边的由右向左移动的游标 high = end while low \u0026lt; high: # 如果low与high未重合，high指向的元素不比基准元素小，则high向左移动 while low \u0026lt; high and alist[high] \u0026gt;= mid: high -= 1 # 将high指向的元素放到low的位置上 alist[low] = alist[high] # 如果low与high未重合，low指向的元素比基准元素小，则low向右移动 while low \u0026lt; high and alist[low] \u0026lt; mid: low += 1 # 将low指向的元素放到high的位置上 alist[high] = alist[low] # 退出循环后，low与high重合，此时所指位置为基准元素的正确位置 # 将基准元素放到该位置 alist[low] = mid # 对基准元素左边的子序列进行快速排序 quick_sort(alist, start, low-1) # 对基准元素右边的子序列进行快速排序 quick_sort(alist, low+1, end) alist = [54,26,93,17,77,31,44,55,20] quick_sort(alist,0,len(alist)-1) print(alist)  [17, 20, 26, 31, 44, 54, 55, 77, 93]  时间复杂度  最优时间复杂度：O($nlogn$)\n横向n，纵向logn($2^x = n, x = logn$) 最坏时间复杂度：O($n^2$)\n横向n，纵向n 稳定性：不稳定  归并排序 merge sort 归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。\n将数组分解最小之后，然后合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。\ndef merge_sort(alist): \u0026quot;归并排序\u0026quot; if len(alist) \u0026lt;= 1: return alist # 二分分解 num = len(alist)//2 left = merge_sort(alist[:num]) right = merge_sort(alist[num:]) # 合并 return merge(left,right) def merge(left, right): '''合并操作，将两个有序数组left[]和right[]合并成一个大的有序数组''' #left与right的下标指针 l, r = 0, 0 result = [] while l\u0026lt;len(left) and r\u0026lt;len(right): if left[l] \u0026lt;= right[r]:#加上=情况，就稳定了 result.append(left[l]) l += 1 else: result.append(right[r]) r += 1 result += left[l:] result += right[r:] return result alist = [54,26,93,17,77,31,44,55,20] sorted_alist = merge_sort(alist) print(sorted_alist)  [17, 20, 26, 31, 44, 54, 55, 77, 93]  时间复杂度  最优时间复杂度：O($nlogn$)\n横向logn($2^x = n, x = logn$)，纵向n 最坏时间复杂度：O($nlogn$)\n需要额外 空间 稳定性：稳定  搜索 二分法 二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好；其缺点是要求待查表为有序表，且插入删除困难。因此，折半查找方法适用于不经常变动而查找频繁的有序列表。首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。\n只能作用在有序的顺序表\ndef binary_search(alist, item): \u0026quot;递归实现\u0026quot; n = len(alist) if n \u0026gt;0: mid = n//2 if alist[mid] == item: return True elif alist[mid]\u0026gt;item: return binary_search(alist[:mid], item) else: return binary_search(alist[mid+1:], item) return False testlist = [0, 1, 2, 8, 13, 17, 19, 32, 42] print(binary_search(testlist, 10)) print(binary_search(testlist, 42))  False True  def binary_search(alist, item): \u0026quot;非递归实现\u0026quot; n = len(alist) first = 0 last = n-1 while first\u0026lt;=last: mid = (first+last)//2 # 不能放在while外层 if alist[mid] == item: return True elif alist[mid]\u0026gt;item: last = mid-1 else: first = mid+1 return False testlist = [0, 1, 2, 8, 13, 17, 19, 32, 42] print(binary_search(testlist, 10)) print(binary_search(testlist, 42))  False True  def binary_search(alist, item): first = 0 last = len(alist)-1 while first\u0026lt;=last: midpoint = (first + last)//2 if alist[midpoint] == item: return True elif item \u0026lt; alist[midpoint]: last = midpoint-1 else: first = midpoint+1 return False testlist = [0, 1, 2, 8, 13, 17, 19, 32, 42,] print(binary_search(testlist, 3)) print(binary_search(testlist, 13))  False True  时间复杂度  最优时间复杂度：O(1) 最坏时间复杂度：O(logn)  ","date":1587772800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587772800,"objectID":"7cd8b787db16aee8324feb3e72397726","permalink":"https://jianzhang6.github.io/blog/data-structure/%E7%AC%94%E8%AE%B0/04/","publishdate":"2020-04-25T00:00:00Z","relpermalink":"/blog/data-structure/%E7%AC%94%E8%AE%B0/04/","section":"blog","summary":"数据结构与算法笔记04","tags":["Note"],"title":"04 排序与搜索","type":"blog"},{"authors":["Jian Zhang"],"categories":["data structure"],"content":"树与树算法 树 树（英语：tree）是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n\u0026gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：\n 每个节点有零个或多个子节点； 没有父节点的节点称为根节点； 每一个非根节点有且只有一个父节点； 除了根节点外，每个子节点可以分为多个不相交的子树；  树的术语  节点的度：一个节点含有的子树的个数称为该节点的度。 B的度：3, G的度：2\n树的度：一棵树中，最大的节点的度称为树的度。 是B/C节点：3\n叶节点或终端节点：度为零的节点。 K,G,F\n父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点。 E的父节点：B\n孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点。\n兄弟节点：具有相同父节点的节点互称为兄弟节点。 D的兄弟节点：E，F\n节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推。 从上往下：A：1， BC：2， DEFGH：3，IJLMN：4，KOP：5\n树的高度或深度：树中节点的最大层次。 最大是5\n堂兄弟节点：父节点在同一层的节点互为堂兄弟。 即爷爷相同，BH互为堂兄弟\n节点的祖先：从根到该节点所经分支上的所有节点。 O的祖先：ACGM\n子孙：以某节点为根的子树中任一节点都称为该节点的子孙。G的子孙：LMO\n森林：由m（m\u0026gt;=0）棵互不相交的树的集合称为森林；\n ###树的种类\n 无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树； 有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；  二叉树：每个节点最多含有两个子树的树称为二叉树；  完全二叉树：对于一颗二叉树，假设其深度为d(d\u0026gt;1)。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树，其中满二叉树的定义是所有叶节点都在最底层的完全二叉树; 平衡二叉树（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树； 排序二叉树（二叉查找树（英语：Binary Search Tree），也称二叉搜索树、有序二叉树）；   霍夫曼树（用于信息编码）：带权路径最短的二叉树称为哈夫曼树或最优二叉树； B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多余两个子树。    常见的一些树的应用场景 1.xml，html等，那么编写这些东西的解析器的时候，不可避免用到树\n2.路由协议就是使用了树的算法\n3.mysql数据库索引\n4.文件系统的目录结构\n5.所以很多经典的AI算法其实都是树搜索，此外机器学习中的decision tree也是树结构\n二叉树 二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）\n二叉树的性质(特性) 性质1:在二叉树的第i层上至多有2^(i-1)个结点\n性质2:深度为k的二叉树至多有2^k - 1个结点\n性质3:对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1;\n性质4:具有n个结点的完全二叉树的深度必为 log2(n+1)\n性质5:对完全二叉树，若从上至下、从左至右编号，则编号为i 的结点，其左孩子编号必为2i，其右孩子编号必为2i＋1；其双亲的编号必为i/2（i＝1 时为根,除外）\nclass Node(object): \u0026quot;节点类\u0026quot; def __init__(self, elem=-1, lchild=None, rchild=None): self.elem = elem self.lchild = lchild self.rchild = rchild class Tree(object): \u0026quot;树类\u0026quot; def __init__(self, root=None): self.root = root def add(self, elem): \u0026quot; 为树添加节点\u0026quot; node = Node(elem) #如果树是空的，则对根节点赋值 if self.root == None: self.root = node else: queue = [] queue.append(self.root) #对已有的节点进行层次遍历 while queue: #弹出队列的第一个元素 cur = queue.pop(0) if cur.lchild == None: cur.lchild = node return elif cur.rchild == None: cur.rchild = node return else: #如果左右子树都不为空，加入队列继续判断 queue.append(cur.lchild) queue.append(cur.rchild) def breadth_travel(self): \u0026quot;广度遍历\u0026quot; if self.root is None: return queue =[self.root] while queue: cur_node = queue.pop(0) print(cur_node.elem,end=\u0026quot; \u0026quot;) if cur_node.lchild is not None: queue.append(cur_node.lchild) if cur_node.rchild is not None: queue.append(cur_node.rchild) def preorder(self, node): \u0026quot;递归实现先序遍历:根左右\u0026quot; if node is None: return print(node.elem,end=\u0026quot; \u0026quot;) self.preorder(node.lchild) self.preorder(node.rchild) def inorder(self, node): \u0026quot;递归实现中序遍历:左根右\u0026quot; if node is None: return self.inorder(node.lchild) print(node.elem,end=\u0026quot; \u0026quot;) self.inorder(node.rchild) def postorder(self, node): \u0026quot;递归实现后续遍历:左右根\u0026quot; if node is None: return self.postorder(node.lchild) self.postorder(node.rchild) print(node.elem, end=\u0026quot; \u0026quot;) tree = Tree() tree.add(0) tree.add(1) tree.add(2) tree.add(3) tree.add(4) tree.add(5) tree.add(6) tree.add(7) tree.add(8) tree.add(9) tree.breadth_travel() print(\u0026quot;\u0026quot;) tree.preorder(tree.root) print(\u0026quot;\u0026quot;) tree.inorder(tree.root) print(\u0026quot;\u0026quot;) tree.postorder(tree.root)  0 1 2 3 4 5 6 7 8 9 0 1 3 7 8 4 9 2 5 6 7 3 8 1 9 4 0 5 2 6 7 8 3 9 4 1 5 6 2 0  树的遍历 树的遍历是树的一种重要的运算。所谓遍历是指对树中所有结点的信息的访问，即依次对树中每个结点访问一次且仅访问一次，我们把这种对所有节点的访问称为遍历（traversal）。那么树的两种重要的遍历模式是深度优先遍历和广度优先遍历,深度优先一般用递归，广度优先一般用队列。一般情况下能用递归实现的算法大部分也能用堆栈来实现\n深度遍历 必须会 对于一颗二叉树，深度优先搜索(Depth First Search)是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。 那么深度遍历有重要的三种方法。这三种方式常被用于访问树的节点，它们之间的不同在于访问每个节点的次序不同。这三种遍历分别叫做先序遍历（preorder），中序遍历（inorder）和后序遍历（postorder）。我们来给出它们的详细定义，然后举例看看它们的应用。  先序遍历 在先序遍历中，我们先访问根节点，然后递归使用先序遍历访问左子树，再递归使用先序遍历访问右子树  根节点-\u0026gt;左子树-\u0026gt;右子树\n前三个元素的话： 0-1-2\ndef preorder(self, node): \u0026quot;递归实现先序遍历:根左右\u0026quot; if node is None: return print(node.elem) self.preorder(node.lchild) self.preorder(node.rchild)   中序遍历 在中序遍历中，我们递归使用中序遍历访问左子树，然后访问根节点，最后再递归使用中序遍历访问右子树  左子树-\u0026gt;根节点-\u0026gt;右子树\n前三个元素的话： 1-0-2\ndef inorder(self, node): \u0026quot;递归实现中序遍历:左根右\u0026quot; if node is None: return self.inorder(node.lchild) print(node.elem) self.inorder(node.rchild)   后序遍历 在后序遍历中，我们先递归使用后序遍历访问左子树和右子树，最后访问根节点  左子树-\u0026gt;右子树-\u0026gt;根节点\n前三个元素的话： 1-2-0\ndef postorder(self, node): \u0026quot;递归实现后续遍历:左右根\u0026quot; if node is None: return self.postorder(node.lchild) self.postorder(node.rchild) print(node.elem)  二叉树反推(拓展) 由遍历确定一棵树 二叉树有三种深度优先遍历方法：先序中序和后序，如果已知中序和先序，或已知中序和后序，可以确定二叉树的结构。\n例：\n 先序：0 1 3 7 8 4 9 2 5 6\n 中序：7 3 8 1 9 4 0 5 2 6\n1、先序找根，中序定两边\n先序的特点是第一个元素是根确定0是根节点，中序的特点是根两侧分别是左右子树确定7 3 8 1 9 4 在0左边，5 2 6在0右边\n所以我们反推分界初始图：\n2、左右分别重复1操作\n所以左侧子树的根节点是1，右侧子树的根节点是2\n3、不停的重复1操作\n最终的二叉树图是：\n完结撒花\n","date":1587772800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587772800,"objectID":"75b81ebd555d83443fe3b0054e74d881","permalink":"https://jianzhang6.github.io/blog/data-structure/%E7%AC%94%E8%AE%B0/05/","publishdate":"2020-04-25T00:00:00Z","relpermalink":"/blog/data-structure/%E7%AC%94%E8%AE%B0/05/","section":"blog","summary":"数据结构与算法笔记05","tags":["Note"],"title":"05 树与树算法","type":"blog"},{"authors":null,"categories":null,"content":"经过一番思想上挣扎，好几次失败终于从Ubuntu16.04+Kinetic升级到18.04+Melodic。😭️\n1. Ubuntu respositories 打开《软件和更新》确保允许\u0026quot;restricted,\u0026rdquo; \u0026ldquo;universe,\u0026rdquo; and \u0026ldquo;multiverse\u0026rdquo; 。\n2. 设置sources.list sudo sh -c 'echo \u0026quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\u0026quot; \u0026gt; /etc/apt/sources.list.d/ros-latest.list'  3. 设置keys sudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654  由于之前安装过其他版本所以是这样\n4. 安装 确保Debian软件包目录索引是最新的\nsudo apt update  安装完整版：\nsudo apt install ros-melodic-desktop-full  5. 初始化rosdep sudo rosdep init rosdep update  6. 环境设置 echo \u0026quot;source /opt/ros/melodic/setup.bash\u0026quot; \u0026gt;\u0026gt; ~/.bashrc  检查是否正确\ngedit ~/ .bashrc  最后几行\n7.软件包的依赖关系 sudo apt-get install python-rosinstall python-rosinstall-generator python-wstool build-essential  8. 检查是否成功安装 新Terminal:\nroscore  OK～＼（≧▽≦）／～啦啦啦\n尝试一下控制小乌龟 新Terminal:\nrosrun turtlesim turtlesim_node  新Terminal:\nrosrun turtlesim turtle_teleop_key  ","date":1584403200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1584403200,"objectID":"1318ff021d2f6373e85281398e6957ce","permalink":"https://jianzhang6.github.io/blog/ros-learning-note/installation-ros/","publishdate":"2020-03-17T00:00:00Z","relpermalink":"/blog/ros-learning-note/installation-ros/","section":"blog","summary":"Melodic安装记录","tags":["Demo"],"title":"ROS Melodic安装记录","type":"blog"},{"authors":["Jian Zhang"],"categories":null,"content":"","date":1579478400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1579478400,"objectID":"3fec4199ca1c616a7fbf0eac00544342","permalink":"https://jianzhang6.github.io/publication/conference-paper/robio2019/","publishdate":"2020-01-20T00:00:00Z","relpermalink":"/publication/conference-paper/robio2019/","section":"publication","summary":"This paper concerns the reconnaissance and surveillance problem for multi-rotor aerial drones or unmanned aerial vehicles (UAVs) flying over geometrically complex environments, such as mountainous terrains and urban regions. In contrast to the existing literature, our approach takes both UAV kinematics constraints and camera sensing constraints into consideration. We present a two-stage strategy to solve this UAV surveillance problem with the given terrain information. In the first stage, the challenge is to find a set of camera locations called the vantage waypoint set to provide full coverage of the area of interest, which can be viewed as a 3D Art Gallery Problem using drones as the observers. In the second stage, one or several UAVs are determined to conduct the full coverage reconnaissance and surveillance duty along individual routes respecting their kinematic constraints in the optimization criterion (the shortest time possible). This variant of the combinatorial traveling salesman problem is solved by introducing unsupervised learning and Bézier curves. The reported results support the feasibility of the proposed solution.","tags":["Obstacle Avoidance","Shortest Path Planning","Reconnaissance","Occlusion-aware","UAV","Coverage"],"title":"Occlusion-aware UAV Path Planning for Reconnaissance and Surveillance in Complex Environments","type":"publication"},{"authors":["Jian Zhang"],"categories":null,"content":"Got a new toy! 🤖️\n","date":1579478400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1582156800,"objectID":"279b9966ca9cf3121ce924dca452bb1c","permalink":"https://jianzhang6.github.io/post/getting-started/","publishdate":"2020-01-20T00:00:00Z","relpermalink":"/post/getting-started/","section":"post","summary":":smile:","tags":["Daily life"],"title":"🤖️ New toy 🤖️","type":"post"},{"authors":["Jian Zhang"],"categories":null,"content":"","date":1575158400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1575158400,"objectID":"5f48c44b48f391da9cec869df8bee73b","permalink":"https://jianzhang6.github.io/publication/conference-paper/anzcc2019/1/","publishdate":"2020-01-02T00:00:00Z","relpermalink":"/publication/conference-paper/anzcc2019/1/","section":"publication","summary":"This work presents a collision-free 3D path planning strategy for the non-holonomic mobile robot. The non-holonomic mobile robot travels through an unknown 3D environment with obstacles and reaches a given destination safely with no collisions. In addition, our approach enables to find the optimal (shortest) path to the target efficiently based on the avoiding plane selected.","tags":["Obstacle Avoidance","Reactive Navigation","Shortest Path Planning","3D Environments","Reinforcement Learning"],"title":"A Collision-Free 3D Path Planning Strategy for Mobile Robots","type":"publication"},{"authors":["Jian Zhang"],"categories":null,"content":"","date":1575158400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1575158400,"objectID":"46e930f7b15050bf0f81b0a3d40bf015","permalink":"https://jianzhang6.github.io/publication/conference-paper/anzcc2019/2/","publishdate":"2019-11-01T00:00:00Z","relpermalink":"/publication/conference-paper/anzcc2019/2/","section":"publication","summary":"This study develops a new path planning method which utilizes integrated environment representation and reinforcement learning to control a mobile robot with non-holonomic constraints in unknown dynamic environments. With the control algorithm presented, no approximating the shapes of the obstacles or even any information about the obstacles' velocities is needed. Our novel approach enables to find the optimal path to the target efficiently and avoid collisions in a cluttered environment with steady and moving obstacles.","tags":["Obstacle Avoidance","Reactive Navigation","Integrated Environment Representation","Dynamic Environments","Reinforcement Learning"],"title":"Path Planning for a Mobile Robot in Unknown Dynamic Environments Using Integrated Environment Representation and Reinforcement Learning","type":"publication"},{"authors":["Jian Zhang"],"categories":null,"content":"I am truly humbled and honored to receive the ANZCC 2019 best paper award. This is clearly one of the most memorable days of my Ph.D. study!\nMy deepest thanks for ANZCC's encouragement！\n😉\n","date":1574985600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1579305600,"objectID":"e63aaeb581247131065a77d16bdfd0de","permalink":"https://jianzhang6.github.io/post/anzcc/","publishdate":"2019-11-29T00:00:00Z","relpermalink":"/post/anzcc/","section":"post","summary":"I am truly humbled and honored to receive the ANZCC 2019 best paper award.","tags":["Daily life"],"title":"ANZCC 2019 Best Paper 🥳","type":"post"},{"authors":["Jian Zhang"],"categories":null,"content":"","date":1561939200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1561939200,"objectID":"0bd1928eaca27d58bf76b945a5a96cbc","permalink":"https://jianzhang6.github.io/publication/conference-paper/ccc2019/","publishdate":"2019-11-01T00:00:00Z","relpermalink":"/publication/conference-paper/ccc2019/","section":"publication","summary":"The reactive collision-free navigation problems are challenging due to the limitation of the environment information. In this paper, we propose a novel hybrid reactive navigation strategy for non-holonomic mobile robots in cluttered environments. Our strategy combines both reactive navigation and Q-learning method.","tags":["Cluttered Environments","Obstacle Avoidance","Reactive Navigation","Shortest Path Planning","Q-Learning","Reinforcement Learning"],"title":"A Hybrid Reactive Navigation Strategy for a Non-holonomic Mobile Robot in Cluttered Environments","type":"publication"},{"authors":["Jian Zhang"],"categories":["Self-driving Cars"],"content":"import numpy as np import matplotlib.pyplot as plt from sklearn import datasets import keras from keras.models import Sequential from keras.layers import Dense from keras.optimizers import Adam from keras.utils.np_utils import to_categorical  n_pts = 500 centers = [[-1, 1], [-1, -1], [1, -1], [1, 1], [0, 0]] X, y = datasets.make_blobs(n_samples=n_pts, random_state=123, centers=centers, cluster_std=0.4)  plt.scatter(X[y==0, 0],X[y==0, 1]) plt.scatter(X[y==1, 0],X[y==1, 1]) plt.scatter(X[y==2, 0],X[y==2, 1]) plt.scatter(X[y==3, 0],X[y==3, 1]) plt.scatter(X[y==4, 0],X[y==4, 1])  \u0026lt;matplotlib.collections.PathCollection at 0x1a33248400\u0026gt;  print(y) y_cat = to_categorical(y,5) print(y_cat)  [3 3 4 0 2 1 1 4 4 4 3 2 1 0 2 4 4 4 3 0 3 0 3 4 1 3 1 0 4 2 3 1 0 4 1 0 4 0 4 0 1 3 3 0 3 1 3 4 0 4 0 2 3 0 2 4 4 0 3 4 1 3 0 4 2 1 1 2 3 2 3 2 1 1 3 2 4 2 2 3 0 2 4 3 2 1 3 3 3 3 1 1 4 2 4 4 1 2 4 1 4 2 2 3 4 1 1 3 3 2 1 3 1 0 1 0 4 4 4 3 1 3 3 3 1 4 4 0 2 0 1 1 0 4 0 1 1 4 4 0 4 3 4 4 2 4 0 0 0 4 2 0 4 1 0 2 2 1 3 0 1 2 2 4 4 1 3 2 3 3 3 2 2 2 4 0 1 1 0 1 4 4 3 2 3 2 3 1 0 3 4 2 1 0 0 0 4 3 0 4 2 2 3 1 0 4 4 1 2 1 3 1 4 4 0 1 4 2 4 0 4 0 1 2 3 0 1 0 3 3 4 3 4 0 0 1 1 3 0 4 1 4 2 1 2 4 4 3 3 1 1 1 4 1 1 1 4 3 1 0 0 2 2 2 3 2 3 4 2 3 3 1 1 0 4 0 3 0 0 0 3 2 2 1 4 2 0 0 2 2 1 3 3 1 3 0 0 1 4 2 2 2 1 0 0 1 0 0 1 2 4 2 4 2 1 3 0 0 1 4 1 2 4 4 4 3 4 1 2 3 1 3 1 0 0 2 4 1 3 1 1 2 1 4 3 1 2 3 2 0 4 1 4 0 2 2 0 1 2 2 4 4 0 4 1 3 3 2 2 0 4 3 3 1 2 2 4 3 0 3 3 3 3 0 1 4 4 4 0 3 3 2 4 0 4 0 0 4 2 2 2 3 0 2 0 0 1 2 3 0 0 2 4 2 3 0 3 0 1 0 4 1 0 0 1 3 1 4 0 2 1 1 3 2 3 2 2 2 3 1 0 0 0 1 3 4 2 1 0 2 1 4 3 3 4 0 0 2 2 0 0 2 2 3 4 3 2 2 2 2 0 1 3 0 2 1 2 0 2 3 4 3 1 4 3 3 0 2 4 0 4 1 3 2 1 3 0 1 2 1] [[0. 0. 0. 1. 0.] [0. 0. 0. 1. 0.] [0. 0. 0. 0. 1.] ... [0. 1. 0. 0. 0.] [0. 0. 1. 0. 0.] [0. 1. 0. 0. 0.]]  model = Sequential() model.add(Dense(units=5, input_shape=(2,), activation='softmax')) model.compile(Adam(0.1), loss='categorical_crossentropy', metrics=['accuracy'])  model.fit(x=X, y=y_cat, verbose=1, batch_size=50, epochs=100)  Epoch 1/100 500/500 [==============================] - 1s 1ms/step - loss: 1.2781 - acc: 0.4940 Epoch 2/100 500/500 [==============================] - 0s 49us/step - loss: 0.6296 - acc: 0.8520 Epoch 3/100 500/500 [==============================] - 0s 47us/step - loss: 0.4182 - acc: 0.9120 Epoch 4/100 500/500 [==============================] - 0s 65us/step - loss: 0.3323 - acc: 0.9440 Epoch 5/100 500/500 [==============================] - 0s 57us/step - loss: 0.2890 - acc: 0.9420 Epoch 6/100 500/500 [==============================] - 0s 50us/step - loss: 0.2626 - acc: 0.9460 Epoch 7/100 500/500 [==============================] - 0s 38us/step - loss: 0.2451 - acc: 0.9440 Epoch 8/100 500/500 [==============================] - 0s 51us/step - loss: 0.2323 - acc: 0.9480 Epoch 9/100 500/500 [==============================] - 0s 40us/step - loss: 0.2217 - acc: 0.9500 Epoch 10/100 500/500 [==============================] - 0s 150us/step - loss: 0.2145 - acc: 0.9500 Epoch 11/100 500/500 [==============================] - 0s 76us/step - loss: 0.2062 - acc: 0.9460 Epoch 12/100 500/500 [==============================] - 0s 72us/step - loss: 0.2001 - acc: 0.9440 Epoch 13/100 500/500 [==============================] - 0s 65us/step - loss: 0.1956 - acc: 0.9500 Epoch 14/100 500/500 [==============================] - 0s 47us/step - loss: 0.1914 - acc: 0.9500 Epoch 15/100 500/500 [==============================] - 0s 85us/step - loss: 0.1877 - acc: 0.9480 Epoch 16/100 500/500 [==============================] - 0s 64us/step - loss: 0.1857 - acc: 0.9460 Epoch 17/100 500/500 [==============================] - 0s 67us/step - loss: 0.1816 - acc: 0.9480 Epoch 18/100 500/500 [==============================] - 0s 60us/step - loss: 0.1811 - acc: 0.9420 Epoch 19/100 500/500 [==============================] - 0s 69us/step - loss: 0.1766 - acc: 0.9500 Epoch 20/100 500/500 [==============================] - 0s 79us/step - loss: 0.1767 - acc: 0.9460 Epoch 21/100 500/500 [==============================] - 0s 53us/step - loss: 0.1721 - acc: 0.9500 Epoch 22/100 500/500 [==============================] - 0s 57us/step - loss: 0.1725 - acc: 0.9460 Epoch 23/100 500/500 [==============================] - 0s 54us/step - loss: 0.1688 - acc: 0.9500 Epoch 24/100 500/500 [==============================] - 0s 69us/step - loss: 0.1693 - acc: 0.9440 Epoch 25/100 500/500 [==============================] - 0s 59us/step - loss: 0.1665 - acc: 0.9480 Epoch 26/100 500/500 [==============================] - 0s 91us/step - loss: 0.1666 - acc: 0.9460 Epoch 27/100 500/500 [==============================] - 0s 63us/step - loss: 0.1650 - acc: 0.9500 Epoch 28/100 500/500 [==============================] - 0s 68us/step - loss: 0.1637 - acc: 0.9520 Epoch 29/100 500/500 [==============================] - 0s 61us/step - loss: 0.1630 - acc: 0.9520 Epoch 30/100 500/500 [==============================] - 0s 76us/step - loss: 0.1634 - acc: 0.9440 Epoch 31/100 500/500 [==============================] - 0s 48us/step - loss: 0.1607 - acc: 0.9500 Epoch 32/100 500/500 [==============================] - 0s 85us/step - loss: 0.1613 - acc: 0.9480 Epoch 33/100 500/500 [==============================] - 0s 65us/step - loss: 0.1604 - acc: 0.9500 Epoch 34/100 500/500 [==============================] - 0s 58us/step - loss: 0.1604 - acc: 0.9480 Epoch 35/100 500/500 [==============================] - 0s 75us/step - loss: 0.1590 - acc: 0.9500 Epoch 36/100 500/500 [==============================] - 0s 52us/step - loss: 0.1590 - acc: 0.9500 Epoch 37/100 500/500 [==============================] - 0s 59us/step - loss: 0.1582 - acc: 0.9500 Epoch 38/100 500/500 [==============================] - 0s 60us/step - loss: 0.1575 - acc: 0.9500 Epoch 39/100 500/500 [==============================] - 0s 62us/step - loss: 0.1592 - acc: 0.9500 Epoch 40/100 500/500 [==============================] - 0s 58us/step - loss: 0.1581 - acc: 0.9460 Epoch 41/100 500/500 [==============================] - 0s 46us/step - loss: 0.1571 - acc: 0.9520 Epoch 42/100 500/500 [==============================] - 0s 55us/step - loss: 0.1562 - acc: 0.9520 Epoch 43/100 500/500 [==============================] - 0s 51us/step - loss: 0.1557 - acc: 0.9480 Epoch 44/100 500/500 [==============================] - 0s 57us/step - loss: 0.1567 - acc: 0.9500 Epoch 45/100 500/500 [==============================] - 0s 55us/step - loss: 0.1556 - acc: 0.9520 Epoch 46/100 500/500 [==============================] - 0s 45us/step - loss: 0.1571 - acc: 0.9480 Epoch 47/100 500/500 [==============================] - 0s 45us/step - loss: 0.1561 - acc: 0.9520 Epoch 48/100 500/500 [==============================] - 0s 42us/step - loss: 0.1555 - acc: 0.9440 Epoch 49/100 500/500 [==============================] - 0s 47us/step - loss: 0.1548 - acc: 0.9440 Epoch 50/100 500/500 [==============================] - 0s 49us/step - loss: 0.1543 - acc: 0.9440 Epoch 51/100 500/500 [==============================] - 0s 40us/step - loss: 0.1537 - acc: 0.9520 Epoch 52/100 500/500 [==============================] - 0s 45us/step - loss: 0.1539 - acc: 0.9500 Epoch 53/100 500/500 [==============================] - 0s 43us/step - loss: 0.1531 - acc: 0.9520 Epoch 54/100 500/500 [==============================] - 0s 47us/step - loss: 0.1550 - acc: 0.9460 Epoch 55/100 500/500 [==============================] - 0s 48us/step - loss: 0.1524 - acc: 0.9520 Epoch 56/100 500/500 [==============================] - 0s 36us/step - loss: 0.1541 - acc: 0.9520 Epoch 57/100 500/500 [==============================] - 0s 49us/step - loss: 0.1538 - acc: 0.9480 Epoch 58/100 500/500 [==============================] - 0s 43us/step - loss: 0.1530 - acc: 0.9480 Epoch 59/100 500/500 [==============================] - 0s 51us/step - loss: 0.1533 - acc: 0.9520 Epoch 60/100 500/500 [==============================] - 0s 38us/step - loss: 0.1528 - acc: 0.9520 Epoch 61/100 500/500 [==============================] - 0s 46us/step - loss: 0.1522 - acc: 0.9500 Epoch 62/100 500/500 [==============================] - 0s 45us/step - loss: 0.1526 - acc: 0.9500 Epoch 63/100 500/500 [==============================] - 0s 51us/step - loss: 0.1527 - acc: 0.9520 Epoch 64/100 500/500 [==============================] - 0s 52us/step - loss: 0.1522 - acc: 0.9500 Epoch 65/100 500/500 [==============================] - 0s 51us/step - loss: 0.1541 - acc: 0.9500 Epoch 66/100 500/500 [==============================] - 0s 41us/step - loss: 0.1521 - acc: 0.9500 Epoch 67/100 500/500 [==============================] - 0s 48us/step - loss: 0.1527 - acc: 0.9520 Epoch 68/100 500/500 [==============================] - 0s 53us/step - loss: 0.1533 - acc: 0.9500 Epoch 69/100 500/500 [==============================] - 0s 48us/step - loss: 0.1540 - acc: 0.9520 Epoch 70/100 500/500 [==============================] - 0s 46us/step - loss: 0.1542 - acc: 0.9460 Epoch 71/100 500/500 [==============================] - 0s 42us/step - loss: 0.1524 - acc: 0.9520 Epoch 72/100 500/500 [==============================] - 0s 42us/step - loss: 0.1535 - acc: 0.9500 Epoch 73/100 500/500 [==============================] - 0s 49us/step - loss: 0.1527 - acc: 0.9500 Epoch 74/100 500/500 [==============================] - 0s 47us/step - loss: 0.1518 - acc: 0.9480 Epoch 75/100 500/500 [==============================] - 0s 45us/step - loss: 0.1533 - acc: 0.9480 Epoch 76/100 500/500 [==============================] - 0s 39us/step - loss: 0.1516 - acc: 0.9500 Epoch 77/100 500/500 [==============================] - 0s 44us/step - loss: 0.1531 - acc: 0.9460 Epoch 78/100 500/500 [==============================] - 0s 45us/step - loss: 0.1555 - acc: 0.9480 Epoch 79/100 500/500 [==============================] - 0s 54us/step - loss: 0.1534 - acc: 0.9480 Epoch 80/100 500/500 [==============================] - 0s 48us/step - loss: 0.1527 - acc: 0.9460 Epoch 81/100 500/500 [==============================] - 0s 59us/step - loss: 0.1532 - acc: 0.9480 Epoch 82/100 500/500 [==============================] - 0s 66us/step - loss: 0.1520 - acc: 0.9480 Epoch 83/100 500/500 [==============================] - 0s 53us/step - loss: 0.1517 - acc: 0.9520 Epoch 84/100 500/500 [==============================] - 0s 55us/step - loss: 0.1524 - acc: 0.9500 Epoch 85/100 500/500 [==============================] - 0s 65us/step - loss: 0.1504 - acc: 0.9520 Epoch 86/100 500/500 [==============================] - 0s 63us/step - loss: 0.1518 - acc: 0.9500 Epoch 87/100 500/500 [==============================] - 0s 53us/step - loss: 0.1524 - acc: 0.9480 Epoch 88/100 500/500 [==============================] - 0s 51us/step - loss: 0.1512 - acc: 0.9480 Epoch 89/100 500/500 [==============================] - 0s 57us/step - loss: 0.1524 - acc: 0.9520 Epoch 90/100 500/500 [==============================] - 0s 62us/step - loss: 0.1524 - acc: 0.9500 Epoch 91/100 500/500 [==============================] - 0s 58us/step - loss: 0.1522 - acc: 0.9520 Epoch 92/100 500/500 [==============================] - 0s 62us/step - loss: 0.1516 - acc: 0.9480 Epoch 93/100 500/500 [==============================] - 0s 53us/step - loss: 0.1525 - acc: 0.9480 Epoch 94/100 500/500 [==============================] - 0s 61us/step - loss: 0.1510 - acc: 0.9520 Epoch 95/100 500/500 [==============================] - 0s 57us/step - loss: 0.1525 - acc: 0.9520 Epoch 96/100 500/500 [==============================] - 0s 38us/step - loss: 0.1504 - acc: 0.9480 Epoch 97/100 500/500 [==============================] - 0s 55us/step - loss: 0.1511 - acc: 0.9500 Epoch 98/100 500/500 [==============================] - 0s 56us/step - loss: 0.1516 - acc: 0.9500 Epoch 99/100 500/500 [==============================] - 0s 46us/step - loss: 0.1503 - acc: 0.9500 Epoch 100/100 500/500 [==============================] - 0s 61us/step - loss: 0.1518 - acc: 0.9480 \u0026lt;keras.callbacks.History at 0x1a332f0940\u0026gt;  def plot_decision_boundary(X, y_cat, model): x_span = np.linspace(min(X[:, 0]) - 1, max(X[:, 0]) + 1) y_span = np.linspace(min(X[:, 1]) - 1, max(X[:, 1]) + 1) xx, yy = np.meshgrid(x_span, y_span) grid = np.c_[xx.ravel(), yy.ravel()] pred_func = model.predict_classes(grid) z = pred_func.reshape(xx.shape) plt.contourf(xx, yy, z)  plot_decision_boundary(X, y_cat, model) plt.scatter(X[y==0, 0],X[y==0, 1]) plt.scatter(X[y==1, 0],X[y==1, 1]) plt.scatter(X[y==2, 0],X[y==2, 1]) plt.scatter(X[y==3, 0],X[y==3, 1]) plt.scatter(X[y==4, 0],X[y==4, 1]) x = 0.5 y = 0.5 point = np.array([[x, y]]) predict = model.predict_classes(point) plt.plot([x], [y], marker='o', markersize=10, color=\u0026quot;yellow\u0026quot;) # plt.show() print(\u0026quot;Prediction is: \u0026quot;, predict)  Prediction is: [3]  ","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"20b7f8d82c7f0f2b471db75b181662be","permalink":"https://jianzhang6.github.io/blog/build-an-autonomous-car-with-python/01/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/blog/build-an-autonomous-car-with-python/01/","section":"blog","summary":"Multiclass Classification Note","tags":["Note"],"title":"01 Computer Vision","type":"blog"},{"authors":[],"categories":[],"content":"Create slides in Markdown with Academic Academic | Documentation\n Features  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides   Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E   Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot; if porridge == \u0026quot;blueberry\u0026quot;: print(\u0026quot;Eating...\u0026quot;)   Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = ;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\n Fragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}} {{% fragment %}} **Two** {{% /fragment %}} {{% fragment %}} Three {{% /fragment %}}  Press Space to play!\nOne  Two  Three \n A fragment can accept two optional parameters:\n class: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears   Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}}  Press the S key to view the speaker notes!\n Only the speaker can read these notes Press S key to view    Themes  black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links    night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links   Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026quot;/img/boards.jpg\u0026quot; \u0026gt;}} {{\u0026lt; slide background-color=\u0026quot;#0000FF\u0026quot; \u0026gt;}} {{\u0026lt; slide class=\u0026quot;my-style\u0026quot; \u0026gt;}}   Custom CSS Example Let's make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; }   Questions? Ask\nDocumentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"https://jianzhang6.github.io/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"An introduction to using Academic's Slides feature.","tags":[],"title":"Slides","type":"slides"}]